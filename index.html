<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Javelin Throwing Arcade – Natural Arm Bend, Landscape & Score</title>
  <style>
    body {
      margin: 0;
      background: #333;
      font-family: 'Press Start 2P', cursive, sans-serif;
      color: #fff;
      text-align: center;
    }
    /* Arcade cabinet container */
    #cabinet {
      width: 840px;
      margin: 40px auto;
      background: #000;
      border: 10px solid #222;
      border-radius: 15px;
      box-shadow: 0 0 20px #000;
      overflow: hidden;
    }
    /* Top section: the game screen */
    #screen {
      background: #87CEEB;
      position: relative;
    }
    #gameCanvas {
      display: block;
      width: 800px;
      height: 400px;
      margin: 20px auto;
      border: 5px inset #000;
      box-shadow: inset 0 0 10px #000;
      background: #87CEEB;
    }
    /* Bottom section: the control panel (trapezoid) */
    #controls {
      position: relative;
      background: #222;
      height: 120px;
      clip-path: polygon(10% 0%, 90% 0%, 100% 100%, 0% 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Arcade button styling */
    #arcadeButton {
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, red 30%, darkred 100%);
      border: 5px solid #000;
      border-radius: 50%;
      box-shadow: 0 5px 10px #000;
      font-size: 20px;
      color: #fff;
      outline: none;
      cursor: pointer;
    }
    /* Result text styling */
    #result {
      margin-top: 10px;
      font-size: 18px;
    }
    /* Disable text selection */
    * {
      user-select: none;
      -webkit-user-select: none;
    }
  </style>
</head>
<body>
  <div id="cabinet">
    <div id="screen">
      <canvas id="gameCanvas" width="800" height="400"></canvas>
    </div>
    <div id="controls">
      <button id="arcadeButton">THROW</button>
    </div>
    <div id="result"></div>
  </div>
  
  <script>
    // === Canvas & Context ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // === Field & Scaling Constants ===
    const fieldWidth = 120;            // Field width in meters
    const bottomMargin = 40;           // Bottom margin (pixels)
    // initialScale: full-field view (zoomed out ~6.67 px/m)
    const initialScale = canvas.width / fieldWidth;
    // finalScale: running view (zoomed in, 50 px/m)
    const finalScale = 50;
    // aimingScale: fixed zoom for aiming (30 px/m)
    const aimingScale = 30;
    
    // === Transition Durations (ms) ===
    const startTransitionDuration = 1000;
    const flightTransitionDuration = 1000;
    const landingTransitionDurationIn = 1000;
    const aimTransitionDuration = 500; // Duration to transition into aiming view
    
    // === Game States ===
    // "ready": waiting (full field view)
    // "startTransition": zooming in to running view
    // "running": runner visible (zoomed in)
    // "aiming": control held to aim; camera transitions to aimingScale
    // "flightZoomOut": after throw, zooming out to full-field view (runner hidden)
    // "thrown": javelin in flight (full field view)
    // "landingZoomIn": after landing, zooming in on landing spot
    // "landed": final view (landing spot, score displayed)
    // "foul": foul (player crosses line without throwing)
    let gameState = "ready";
    let resultText = "Press the button or Space to start running.";
    
    let transitionStartTime = null;
    let flightTransitionStartTime = null;
    let landingTransitionStartTime = null;
    let aimTransitionStartTime = null;
    
    // For landing zoom interpolation:
    let landingZoomStartCameraX = null;
    let landingZoomStartScale = null;
    let landingCameraX = null;
    
    // === World Physics (SI units) ===
    const gravity = -9.81;           // m/s² downward
    const playerSpeed = 7;           // m/s
    const throwSpeed = 30;           // m/s
    const minAngle = 20 * Math.PI / 180; // radians
    const maxAngle = 60 * Math.PI / 180; // radians
    const maxHoldTime = 2000;        // ms max for aiming
    
    // Realistic drag parameters:
    const airDensity = 1.225;        // kg/m³ (sea level)
    const dragCoefficient = 0.5;
    const javelinArea = 0.007;       // m²
    const javelinMass = 0.8;         // kg
    
    // === World Objects ===
    // Player's x position represents his foot contact with the ground.
    let player = { x: 0, y: 0 };
    // For the runner, assume head radius 0.2 m, total height ~1.8 m.
    const foulLineX = 30;            // foul (throwing) line (meters)
    
    // The javelin is initially attached to the runner’s hand.
    let javelin = { x: 0, y: 0, vx: 0, vy: 0 };
    const javelinLength = 1.2;       // m
    
    let frozenPlayerX = 0;           // Freeze player's x at throw time.
    
    // === Input Control Variables ===
    let spacePressed = false;
    let holdStartTime = 0;
    let holdDuration = 0;
    
    // Global runner animation time:
    let runnerTime = 0;
    
    // === Arcade Button & Keyboard Functions ===
    function pressSpace() {
      if (gameState === "ready") {
        gameState = "startTransition";
        transitionStartTime = performance.now();
        resultText = "";
      } else if (gameState === "running") {
        gameState = "aiming";
        spacePressed = true;
        holdStartTime = performance.now();
        holdDuration = 0;
        aimTransitionStartTime = performance.now();
      }
    }
    function releaseSpace() {
      if (gameState === "aiming" && spacePressed) {
        spacePressed = false;
        let angleFactor = Math.min(holdDuration, maxHoldTime) / maxHoldTime;
        let aimAngle = minAngle + (maxAngle - minAngle) * angleFactor;
        // Set javelin initial conditions based on aim.
        javelin.x = player.x;
        javelin.y = player.y + 1.5; // approximate hand height
        javelin.vx = playerSpeed + throwSpeed * Math.cos(aimAngle);
        javelin.vy = throwSpeed * Math.sin(aimAngle);
        frozenPlayerX = player.x;
        gameState = "flightZoomOut";
        flightTransitionStartTime = performance.now();
        aimTransitionStartTime = null;
      }
    }
    
    const arcadeButton = document.getElementById('arcadeButton');
    arcadeButton.addEventListener('mousedown', pressSpace);
    arcadeButton.addEventListener('touchstart', function(e) {
      e.preventDefault();
      pressSpace();
    });
    arcadeButton.addEventListener('mouseup', releaseSpace);
    arcadeButton.addEventListener('touchend', function(e) {
      e.preventDefault();
      releaseSpace();
    });
    
    document.addEventListener('keydown', function(e) {
      if (e.code === "Space") { pressSpace(); }
      if (e.code === "KeyR") { resetGame(); }
    });
    document.addEventListener('keyup', function(e) {
      if (e.code === "Space") { releaseSpace(); }
    });
    
    // === Camera & View Functions ===
    function getCameraAndScale() {
      let scale, cameraX;
      if (gameState === "ready") {
        scale = initialScale;
        cameraX = 0;
      } else if (gameState === "startTransition") {
        let elapsed = performance.now() - transitionStartTime;
        let fraction = Math.min(elapsed / startTransitionDuration, 1);
        scale = initialScale + fraction * (finalScale - initialScale);
        let runningCameraX = player.x - (canvas.width / (2 * finalScale));
        cameraX = fraction * runningCameraX;
      } else if (gameState === "running") {
        scale = finalScale;
        cameraX = player.x - (canvas.width / (2 * finalScale));
      } else if (gameState === "aiming") {
        let elapsed = performance.now() - aimTransitionStartTime;
        let fraction = Math.min(elapsed / aimTransitionDuration, 1);
        scale = finalScale + fraction * (aimingScale - finalScale);
        cameraX = player.x - (canvas.width / (2 * scale));
      } else if (gameState === "flightZoomOut") {
        let elapsed = performance.now() - flightTransitionStartTime;
        let fraction = Math.min(elapsed / flightTransitionDuration, 1);
        scale = finalScale + fraction * (initialScale - finalScale);
        let runningCameraX = frozenPlayerX - (canvas.width / (2 * finalScale));
        let fullFieldCameraX = javelin.x - (canvas.width / (2 * initialScale));
        cameraX = runningCameraX + fraction * (fullFieldCameraX - runningCameraX);
      } else if (gameState === "thrown") {
        scale = initialScale;
        cameraX = javelin.x - (canvas.width / (2 * initialScale));
      } else if (gameState === "landingZoomIn") {
        let elapsed = performance.now() - landingTransitionStartTime;
        let fraction = Math.min(elapsed / landingTransitionDurationIn, 1);
        scale = landingZoomStartScale + fraction * (finalScale - landingZoomStartScale);
        cameraX = landingZoomStartCameraX + fraction * (landingCameraX - landingZoomStartCameraX);
      } else if (gameState === "landed") {
        scale = finalScale;
        cameraX = landingCameraX;
      } else if (gameState === "foul") {
        scale = finalScale;
        cameraX = frozenPlayerX - (canvas.width / (2 * finalScale));
      }
      return { scale, cameraX };
    }
    
    function worldToScreen(x, y) {
      const { scale, cameraX } = getCameraAndScale();
      return {
        screenX: (x - cameraX) * scale,
        screenY: canvas.height - bottomMargin - y * scale
      };
    }
    
    // === Draw Landscape: Hills and Trees with Varied Size and Color ===
    function drawLandscape() {
      const { scale, cameraX } = getCameraAndScale();
      
      // Draw several taller hills.
      const hills = [
        { xStart: 5, xEnd: 35, peakX: 20, peakY: 8, color: "#556B2F" },
        { xStart: 40, xEnd: 70, peakX: 55, peakY: 7, color: "#6B8E23" },
        { xStart: 75, xEnd: 110, peakX: 92, peakY: 9, color: "#2E8B57" },
        { xStart: 100, xEnd: 130, peakX: 115, peakY: 7, color: "#3CB371" }
      ];
      hills.forEach(hill => {
        ctx.fillStyle = hill.color;
        ctx.beginPath();
        let start = worldToScreen(hill.xStart, 0);
        ctx.moveTo(start.screenX, start.screenY);
        let peak = worldToScreen(hill.peakX, hill.peakY);
        let end = worldToScreen(hill.xEnd, 0);
        ctx.quadraticCurveTo(peak.screenX, peak.screenY, end.screenX, end.screenY);
        ctx.lineTo(end.screenX, canvas.height - bottomMargin);
        ctx.lineTo(start.screenX, canvas.height - bottomMargin);
        ctx.closePath();
        ctx.fill();
      });
      
      // Draw trees with varied sizes and colors.
      const trees = [
        { x: 15, scale: 1.0, trunkColor: "#8B4513", foliageColor: "#228B22" },
        { x: 30, scale: 0.8, trunkColor: "#A0522D", foliageColor: "#006400" },
        { x: 50, scale: 1.2, trunkColor: "#8B4513", foliageColor: "#32CD32" },
        { x: 80, scale: 1.0, trunkColor: "#A0522D", foliageColor: "#228B22" },
        { x: 100, scale: 0.9, trunkColor: "#8B4513", foliageColor: "#006400" },
        { x: 120, scale: 1.1, trunkColor: "#8B4513", foliageColor: "#2E8B57" }
      ];
      trees.forEach(tree => {
        drawTree(tree.x, 0, tree.scale, tree.trunkColor, tree.foliageColor);
      });
    }
    
    // Draw a single tree at world x, ground y with a given treeScale.
    function drawTree(x, groundY, treeScale, trunkColor, foliageColor) {
      // Trunk dimensions (in meters)
      const trunkWidth = 0.2 * treeScale;
      const trunkHeight = 1.0 * treeScale;
      const trunkX = x - trunkWidth / 2;
      const trunkY = groundY;
      let trunkScreen = worldToScreen(trunkX, trunkY);
      const { scale } = getCameraAndScale();
      ctx.fillStyle = trunkColor;
      ctx.fillRect(trunkScreen.screenX, trunkScreen.screenY - trunkHeight * scale, trunkWidth * scale, trunkHeight * scale);
      
      // Foliage: a circle above the trunk.
      const foliageRadius = 0.5 * treeScale;
      const foliageX = x;
      const foliageY = groundY + trunkHeight + foliageRadius;
      let foliageScreen = worldToScreen(foliageX, foliageY);
      ctx.fillStyle = foliageColor;
      ctx.beginPath();
      ctx.arc(foliageScreen.screenX, foliageScreen.screenY, foliageRadius * scale, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // === Draw Meter Markings (every 5 m) ===
    function drawMeterMarkings(cameraX, scale) {
      ctx.fillStyle = "black";
      ctx.strokeStyle = "black";
      ctx.font = "12px Arial";
      let startMark = Math.ceil(cameraX / 5) * 5;
      let endMark = Math.floor((cameraX + canvas.width / scale) / 5) * 5;
      for (let m = startMark; m <= endMark; m += 5) {
        let xPos = (m - cameraX) * scale;
        ctx.beginPath();
        ctx.moveTo(xPos, canvas.height - bottomMargin);
        ctx.lineTo(xPos, canvas.height - bottomMargin + 10);
        ctx.stroke();
        ctx.fillText(m + " m", xPos - 15, canvas.height - bottomMargin + 22);
      }
    }
    
    // === Draw Distance Indicator (Sideways Red Raindrop) ===
    // Before throw: shows meters remaining to the foul line.
    // After throw: shows score (distance traveled from throw point).
    function drawDistanceIndicator() {
      let value, label;
      if (gameState === "running" || gameState === "aiming" || gameState === "ready") {
        value = Math.floor(foulLineX - player.x);
        label = "To Foul: ";
      } else {
        value = Math.floor(javelin.x - frozenPlayerX);
        label = "Score: ";
      }
      const dropWidth = 60, dropHeight = 30;
      const dropX = canvas.width - dropWidth - 20, dropY = 20;
      
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.moveTo(dropX, dropY + dropHeight / 2);
      ctx.quadraticCurveTo(dropX + dropWidth, dropY, dropX + dropWidth, dropY + dropHeight / 2);
      ctx.quadraticCurveTo(dropX + dropWidth, dropY + dropHeight, dropX, dropY + dropHeight / 2);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = "white";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label + value + " m", dropX + dropWidth / 2, dropY + dropHeight / 2);
    }
    
    // === Realistic Javelin Physics Update Function ===
    function updateJavelinPhysics(dt) {
      let vx = javelin.vx, vy = javelin.vy;
      let v = Math.sqrt(vx * vx + vy * vy);
      if (v > 0) {
        let dragForce = 0.5 * airDensity * v * v * dragCoefficient * javelinArea;
        let dragAccel = dragForce / javelinMass;
        let dragAx = -dragAccel * (vx / v);
        let dragAy = -dragAccel * (vy / v);
        javelin.vx += dragAx * dt;
        javelin.vy += dragAy * dt;
      }
      javelin.vy += gravity * dt;
      javelin.x += javelin.vx * dt;
      javelin.y += javelin.vy * dt;
    }
    
    // === Draw the Runner (Enhanced Dashing Stick Figure with Natural Bent Arm) ===
    // This function draws a runner with a pronounced forward lean, exaggerated limb swings,
    // and a natural bend in the back arm (holding the javelin). The arm is drawn with an elbow joint.
    // Returns the right-hand position (world coordinates) where the javelin is attached.
    function drawRunner(x, scale, time, aiming, aimAngle) {
      const headRadius = 0.2;
      const headY = 1.8;  // Head center (drawn separately)
      const bodyTopY = 1.5;
      const hipY = 1.0;
      // Increase forward lean: shoulders shifted further ahead.
      const shoulderOffset = 0.3;
      const hipOffset = 0.1;
      
      // Draw head (separate circle).
      let shoulderX = x + shoulderOffset;
      let headPos = worldToScreen(shoulderX, headY);
      ctx.fillStyle = "#ffe0bd";
      ctx.beginPath();
      ctx.arc(headPos.screenX, headPos.screenY, headRadius * scale, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw body: from shoulder to hip.
      let bodyTop = worldToScreen(shoulderX, bodyTopY);
      let hipX = x + hipOffset;
      let bodyBottom = worldToScreen(hipX, hipY);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(bodyTop.screenX, bodyTop.screenY);
      ctx.lineTo(bodyBottom.screenX, bodyBottom.screenY);
      ctx.stroke();
      
      // Draw arms.
      // Left arm: extended forward (front arm).
      let leftArmEnd = { x: shoulderX - 0.4, y: bodyTopY - 0.1 };
      let leftArmEndScreen = worldToScreen(leftArmEnd.x, leftArmEnd.y);
      ctx.beginPath();
      ctx.moveTo(bodyTop.screenX, bodyTop.screenY);
      ctx.lineTo(leftArmEndScreen.screenX, leftArmEndScreen.screenY);
      ctx.stroke();
      
      // Right arm (back arm) holding the javelin: draw with a natural elbow bend.
      // Upper arm length and lower arm length (in meters):
      const upperArmLength = 0.3;
      const lowerArmLength = 0.2;
      // Desired hand position from the throw (using aimAngle if aiming, else default angle).
      let defaultArmAngle = (20 * Math.PI / 180) + 0.2 * Math.sin(time * 8);
      let rightArmAngle = aiming ? aimAngle : defaultArmAngle;
      // Desired hand position if arm were fully extended in a straight line:
      let handDesired = {
        x: shoulderX + (upperArmLength + lowerArmLength) * Math.cos(rightArmAngle),
        y: bodyTopY - (upperArmLength + lowerArmLength) * Math.sin(rightArmAngle)
      };
      // Now, compute the elbow position as the intersection of:
      // Circle centered at shoulder with radius upperArmLength,
      // and circle centered at handDesired with radius lowerArmLength.
      let S = { x: shoulderX, y: bodyTopY };
      let H = handDesired;
      let dx = H.x - S.x;
      let dy = H.y - S.y;
      let d = Math.sqrt(dx * dx + dy * dy);
      // Prevent division by zero.
      if(d === 0) d = 0.001;
      // Using circle intersection formulas:
      let a = (upperArmLength*upperArmLength - lowerArmLength*lowerArmLength + d*d) / (2*d);
      let h = Math.sqrt(Math.max(0, upperArmLength*upperArmLength - a*a));
      // Base point along the line from S to H.
      let rx = dx / d;
      let ry = dy / d;
      let P = { x: S.x + a * rx, y: S.y + a * ry };
      // Two intersection points: P ± h * (-ry, rx)
      let E1 = { x: P.x - h * ry, y: P.y + h * rx };
      let E2 = { x: P.x + h * ry, y: P.y - h * rx };
      // Choose the elbow with a lower y (closer to the ground) for a natural bend.
      let E = (E1.y < S.y) ? E1 : E2;
      // The final hand position will be drawn from E, at distance lowerArmLength along the direction to H.
      let EHdx = H.x - E.x;
      let EHdy = H.y - E.y;
      let EHd = Math.sqrt(EHdx * EHdx + EHdy * EHdy);
      if(EHd === 0) EHd = 0.001;
      let handPos = {
        x: E.x + lowerArmLength * (EHdx / EHd),
        y: E.y + lowerArmLength * (EHdy / EHd)
      };
      
      // Draw upper arm: shoulder to elbow.
      let shoulderScreen = worldToScreen(S.x, S.y);
      let elbowScreen = worldToScreen(E.x, E.y);
      ctx.beginPath();
      ctx.moveTo(shoulderScreen.screenX, shoulderScreen.screenY);
      ctx.lineTo(elbowScreen.screenX, elbowScreen.screenY);
      ctx.stroke();
      
      // Draw lower arm: elbow to hand.
      let handScreen = worldToScreen(handPos.x, handPos.y);
      ctx.beginPath();
      ctx.moveTo(elbowScreen.screenX, elbowScreen.screenY);
      ctx.lineTo(handScreen.screenX, handScreen.screenY);
      ctx.stroke();
      
      // Return the hand position (world coordinates) for attaching the javelin.
      return handPos;
    }
    
    // === Draw Javelin Attached to Runner's Hand ===
    function drawJavelinAtHand(handPos, scale, angle) {
      let posScreen = worldToScreen(handPos.x, handPos.y);
      ctx.save();
      ctx.translate(posScreen.screenX, posScreen.screenY);
      ctx.rotate(-angle); // Negative for proper orientation.
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(javelinLength * scale, 0);
      ctx.stroke();
      ctx.restore();
    }
    
    // === Main Game Loop ===
    let lastTime = 0;
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      
      runnerTime += dt;
      
      update(dt);
      draw();
      
      document.getElementById("result").innerText = resultText;
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
    
    // === Update Game State ===
    function update(dt) {
      if (gameState === "startTransition") {
        let elapsed = performance.now() - transitionStartTime;
        if (elapsed >= startTransitionDuration) {
          gameState = "running";
        }
      }
      
      if (gameState === "running" || gameState === "aiming") {
        player.x += playerSpeed * dt;
        if (player.x > foulLineX) {
          gameState = "foul";
          resultText = "Foul! You crossed the line without throwing. Press R to restart.";
        }
        if (gameState === "aiming" && spacePressed) {
          holdDuration = performance.now() - holdStartTime;
        }
      }
      
      if (gameState === "flightZoomOut" || gameState === "thrown" || gameState === "landingZoomIn") {
        updateJavelinPhysics(dt);
        if (javelin.y <= 0) {
          javelin.y = 0;
          javelin.vx = 0;
          javelin.vy = 0;
          if (gameState !== "landingZoomIn") {
            landingZoomStartScale = initialScale;
            landingZoomStartCameraX = javelin.x - (canvas.width / (2 * initialScale));
            landingCameraX = javelin.x - (canvas.width / (2 * finalScale));
            gameState = "landingZoomIn";
            landingTransitionStartTime = performance.now();
          }
        }
        if (gameState === "flightZoomOut") {
          let elapsed = performance.now() - flightTransitionStartTime;
          if (elapsed >= flightTransitionDuration) {
            gameState = "thrown";
          }
        }
      }
      
      if (gameState === "landingZoomIn") {
        let elapsed = performance.now() - landingTransitionStartTime;
        if (elapsed >= landingTransitionDurationIn) {
          gameState = "landed";
          let score = Math.floor(javelin.x - frozenPlayerX);
          resultText = "Score: " + score + " m. Press R to restart.";
        }
      }
    }
    
    // === Draw Everything ===
    function draw() {
      const { scale, cameraX } = getCameraAndScale();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw sky.
      let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, "#87CEEB");
      skyGradient.addColorStop(1, "#B0E0E6");
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw background landscape.
      drawLandscape();
      
      // Draw ground.
      ctx.fillStyle = "#228B22";
      ctx.fillRect(0, canvas.height - bottomMargin, canvas.width, bottomMargin);
      
      drawMeterMarkings(cameraX, scale);
      
      let foulScreen = worldToScreen(foulLineX, 0);
      ctx.strokeStyle = "red";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(foulScreen.screenX, 0);
      ctx.lineTo(foulScreen.screenX, canvas.height);
      ctx.stroke();
      
      // In running or aiming state, draw the runner with attached javelin.
      if (gameState === "running" || gameState === "aiming") {
        let currentAimAngle = (gameState === "aiming")
          ? (minAngle + (maxAngle - minAngle) * Math.min(holdDuration, maxHoldTime) / maxHoldTime)
          : ((20 * Math.PI / 180) + 0.2 * Math.sin(runnerTime * 8));
        let rightHandPos = drawRunner(player.x, scale, runnerTime, gameState === "aiming", currentAimAngle);
        drawJavelinAtHand(rightHandPos, scale, currentAimAngle);
      }
      
      // In flight and later states, draw the javelin using physics.
      if (gameState === "flightZoomOut" || gameState === "thrown" ||
          gameState === "landingZoomIn" || gameState === "landed") {
        let pos = worldToScreen(javelin.x, javelin.y);
        let angle = Math.atan2(-javelin.vy, javelin.vx);
        ctx.save();
        ctx.translate(pos.screenX, pos.screenY);
        ctx.rotate(angle);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(javelinLength * scale, 0);
        ctx.stroke();
        ctx.restore();
      }
      
      drawDistanceIndicator();
      
      if (gameState === "ready") {
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    function resetGame() {
      gameState = "ready";
      resultText = "Press the button or Space to start running.";
      player.x = 0;
      player.y = 0;
      javelin = { x: 0, y: 0, vx: 0, vy: 0 };
      frozenPlayerX = 0;
      spacePressed = false;
      holdDuration = 0;
      holdStartTime = 0;
      transitionStartTime = null;
      flightTransitionStartTime = null;
      landingTransitionStartTime = null;
      aimTransitionStartTime = null;
    }
  </script>
</body>
</html>

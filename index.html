<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Javelin Throwing Arcade – Attached Limbs & Approach Angle Stick</title>
  <style>
    body {
      margin: 0;
      background: #333;
      font-family: 'Press Start 2P', cursive, sans-serif;
      color: #fff;
      text-align: center;
    }
    #cabinet {
      width: 840px;
      margin: 40px auto;
      background: #000;
      border: 10px solid #222;
      border-radius: 15px;
      box-shadow: 0 0 20px #000;
      overflow: hidden;
    }
    #screen {
      background: #87CEEB;
      position: relative;
    }
    #gameCanvas {
      display: block;
      width: 800px;
      height: 400px;
      margin: 20px auto;
      border: 5px inset #000;
      box-shadow: inset 0 0 10px #000;
      background: #87CEEB;
    }
    #controls {
      position: relative;
      background: #222;
      height: 120px;
      clip-path: polygon(10% 0%, 90% 0%, 100% 100%, 0% 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #arcadeButton {
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, red 30%, darkred 100%);
      border: 5px solid #000;
      border-radius: 50%;
      box-shadow: 0 5px 10px #000;
      font-size: 20px;
      color: #fff;
      outline: none;
      cursor: pointer;
    }
    #result {
      margin-top: 10px;
      font-size: 18px;
    }
    * {
      user-select: none;
      -webkit-user-select: none;
    }
  </style>
</head>
<body>
  <div id="cabinet">
    <div id="screen">
      <canvas id="gameCanvas" width="800" height="400"></canvas>
    </div>
    <div id="controls">
      <button id="arcadeButton">THROW</button>
    </div>
    <div id="result"></div>
  </div>
  
  <script>
    // === Setup and Constants ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const fieldWidth = 120;
    const bottomMargin = 40;
    const initialScale = canvas.width / fieldWidth; // ~6.67 px/m
    const finalScale = 50; // Running view
    const aimingScale = 30; // Aiming view
    
    const startTransitionDuration = 1000;
    const flightTransitionDuration = 1000;
    const landingTransitionDurationIn = 1000;
    const aimTransitionDuration = 500;
    
    // Game states
    let gameState = "ready";
    let resultText = "Press the button or Space to start running.";
    
    let transitionStartTime = null;
    let flightTransitionStartTime = null;
    let landingTransitionStartTime = null;
    let aimTransitionStartTime = null;
    
    // For landing zoom interpolation
    let landingZoomStartCameraX = null;
    let landingZoomStartScale = null;
    let landingCameraX = null;
    
    // Physics
    const gravity = -9.81;
    const playerSpeed = 7;
    const throwSpeed = 30; // constant throw speed
    const minAngle = 20 * Math.PI/180;
    const maxAngle = 60 * Math.PI/180;
    const maxHoldTime = 2000; // only used for angle interpolation
    
    // Drag parameters
    const airDensity = 1.225;
    const dragCoefficient = 0.5;
    const javelinArea = 0.007;
    const javelinMass = 0.8;
    
    // Player, javelin, foul line
    let player = { x: 0, y: 0 };
    const foulLineX = 30;
    let javelin = { x: 0, y: 0, vx: 0, vy: 0 };
    const javelinLength = 1.2;
    let frozenPlayerX = 0;
    let finalAngle = 0; // final javelin angle upon landing
    
    // Input variables
    let spacePressed = false;
    let holdStartTime = 0;
    let holdDuration = 0;
    let runnerTime = 0;
    
    // === Arcade Button & Keyboard Functions ===
    function pressSpace() {
      if (gameState === "ready") {
        gameState = "startTransition";
        transitionStartTime = performance.now();
        resultText = "";
      } else if (gameState === "running") {
        gameState = "aiming";
        spacePressed = true;
        holdStartTime = performance.now();
        holdDuration = 0;
        aimTransitionStartTime = performance.now();
      }
    }
    function releaseSpace() {
      if (gameState === "aiming" && spacePressed) {
        spacePressed = false;
        let angleFactor = Math.min(holdDuration, maxHoldTime) / maxHoldTime;
        let aimAngle = minAngle + (maxAngle - minAngle) * angleFactor;
        // Throw javelin with constant speed
        javelin.x = player.x;
        javelin.y = player.y + 1.5;
        javelin.vx = playerSpeed + throwSpeed * Math.cos(aimAngle);
        javelin.vy = throwSpeed * Math.sin(aimAngle);
        frozenPlayerX = player.x;
        gameState = "flightZoomOut";
        flightTransitionStartTime = performance.now();
        aimTransitionStartTime = null;
      }
    }
    
    const arcadeButton = document.getElementById('arcadeButton');
    arcadeButton.addEventListener('mousedown', pressSpace);
    arcadeButton.addEventListener('touchstart', function(e) {
      e.preventDefault();
      pressSpace();
    });
    arcadeButton.addEventListener('mouseup', releaseSpace);
    arcadeButton.addEventListener('touchend', function(e) {
      e.preventDefault();
      releaseSpace();
    });
    
    document.addEventListener('keydown', function(e) {
      if (e.code === "Space") { pressSpace(); }
      if (e.code === "KeyR") { resetGame(); }
    });
    document.addEventListener('keyup', function(e) {
      if (e.code === "Space") { releaseSpace(); }
    });
    
    // === Camera & Scale ===
    function getCameraAndScale() {
      let scale, cameraX;
      if (gameState === "ready") {
        scale = initialScale;
        cameraX = 0;
      } else if (gameState === "startTransition") {
        let elapsed = performance.now() - transitionStartTime;
        let fraction = Math.min(elapsed / startTransitionDuration, 1);
        scale = initialScale + fraction * (finalScale - initialScale);
        let runningCameraX = player.x - (canvas.width / (2 * finalScale));
        cameraX = fraction * runningCameraX;
      } else if (gameState === "running") {
        scale = finalScale;
        cameraX = player.x - (canvas.width / (2 * finalScale));
      } else if (gameState === "aiming") {
        let elapsed = performance.now() - aimTransitionStartTime;
        let fraction = Math.min(elapsed / aimTransitionDuration, 1);
        scale = finalScale + fraction * (aimingScale - finalScale);
        cameraX = player.x - (canvas.width / (2 * scale));
      } else if (gameState === "flightZoomOut") {
        let elapsed = performance.now() - flightTransitionStartTime;
        let fraction = Math.min(elapsed / flightTransitionDuration, 1);
        scale = finalScale + fraction * (initialScale - finalScale);
        let runningCameraX = frozenPlayerX - (canvas.width / (2 * finalScale));
        let fullFieldCameraX = javelin.x - (canvas.width / (2 * initialScale));
        cameraX = runningCameraX + fraction * (fullFieldCameraX - runningCameraX);
      } else if (gameState === "thrown") {
        scale = initialScale;
        cameraX = javelin.x - (canvas.width / (2 * initialScale));
      } else if (gameState === "landingZoomIn") {
        let elapsed = performance.now() - landingTransitionStartTime;
        let fraction = Math.min(elapsed / landingTransitionDurationIn, 1);
        scale = landingZoomStartScale + fraction * (finalScale - landingZoomStartScale);
        cameraX = landingZoomStartCameraX + fraction * (landingCameraX - landingZoomStartCameraX);
      } else if (gameState === "landed") {
        scale = finalScale;
        cameraX = landingCameraX;
      } else if (gameState === "foul") {
        scale = finalScale;
        cameraX = frozenPlayerX - (canvas.width / (2 * finalScale));
      }
      return { scale, cameraX };
    }
    
    function worldToScreen(x, y) {
      const { scale, cameraX } = getCameraAndScale();
      return {
        screenX: (x - cameraX) * scale,
        screenY: canvas.height - bottomMargin - y * scale
      };
    }
    
    // === Draw Landscape ===
    function drawLandscape() {
      const hills = [
        { xStart: 5, xEnd: 35, peakX: 20, peakY: 10, color: "#556B2F" },
        { xStart: 40, xEnd: 70, peakX: 55, peakY: 9, color: "#6B8E23" },
        { xStart: 75, xEnd: 110, peakX: 92, peakY: 12, color: "#2E8B57" },
        { xStart: 100, xEnd: 140, peakX: 120, peakY: 8, color: "#3CB371" }
      ];
      hills.forEach(h => drawHill(h.xStart, h.xEnd, h.peakX, h.peakY, h.color));
      
      const trees = [
        { x: 15, scale: 1.0, trunkColor: "#8B4513", foliageColor: "#228B22" },
        { x: 30, scale: 0.8, trunkColor: "#A0522D", foliageColor: "#006400" },
        { x: 50, scale: 1.2, trunkColor: "#8B4513", foliageColor: "#32CD32" },
        { x: 80, scale: 1.0, trunkColor: "#A0522D", foliageColor: "#228B22" },
        { x: 100, scale: 0.9, trunkColor: "#8B4513", foliageColor: "#006400" },
        { x: 120, scale: 1.1, trunkColor: "#8B4513", foliageColor: "#2E8B57" },
        { x: 135, scale: 1.0, trunkColor: "#8B4513", foliageColor: "#228B22" }
      ];
      trees.forEach(t => drawTree(t.x, 0, t.scale, t.trunkColor, t.foliageColor));
    }
    function drawHill(xStart, xEnd, peakX, peakY, color) {
      ctx.fillStyle = color;
      let start = worldToScreen(xStart, 0);
      let peak = worldToScreen(peakX, peakY);
      let end = worldToScreen(xEnd, 0);
      ctx.beginPath();
      ctx.moveTo(start.screenX, start.screenY);
      ctx.quadraticCurveTo(peak.screenX, peak.screenY, end.screenX, end.screenY);
      ctx.lineTo(end.screenX, canvas.height - bottomMargin);
      ctx.lineTo(start.screenX, canvas.height - bottomMargin);
      ctx.closePath();
      ctx.fill();
    }
    function drawTree(x, groundY, treeScale, trunkColor, foliageColor) {
      let trunkWidth = 0.2 * treeScale;
      let trunkHeight = 1.0 * treeScale;
      let trunkX = x - trunkWidth/2;
      let trunkY = groundY;
      let trunkScr = worldToScreen(trunkX, trunkY);
      const { scale } = getCameraAndScale();
      ctx.fillStyle = trunkColor;
      ctx.fillRect(trunkScr.screenX, trunkScr.screenY - trunkHeight*scale, trunkWidth*scale, trunkHeight*scale);
      
      let foliageRadius = 0.5 * treeScale;
      let foliageX = x;
      let foliageY = groundY + trunkHeight + foliageRadius;
      let foliageScr = worldToScreen(foliageX, foliageY);
      ctx.fillStyle = foliageColor;
      ctx.beginPath();
      ctx.arc(foliageScr.screenX, foliageScr.screenY, foliageRadius*scale, 0, Math.PI*2);
      ctx.fill();
    }
    
    // === Draw Meter Markings ===
    function drawMeterMarkings(cameraX, scale) {
      ctx.fillStyle = "black";
      ctx.strokeStyle = "black";
      ctx.font = "12px Arial";
      let startMark = Math.ceil(cameraX/5)*5;
      let endMark = Math.floor((cameraX + canvas.width/scale)/5)*5;
      for(let m = startMark; m <= endMark; m += 5) {
        let xPos = (m - cameraX)*scale;
        ctx.beginPath();
        ctx.moveTo(xPos, canvas.height - bottomMargin);
        ctx.lineTo(xPos, canvas.height - bottomMargin+10);
        ctx.stroke();
        ctx.fillText(m+" m", xPos-15, canvas.height - bottomMargin+22);
      }
    }
    
    // === Draw Distance Indicator (Sideways Red Raindrop) ===
    function drawDistanceIndicator() {
      let value, label;
      if(gameState === "running" || gameState === "aiming" || gameState === "ready") {
        value = Math.floor(foulLineX - player.x);
        label = "To Foul: ";
      } else {
        value = Math.floor(javelin.x - frozenPlayerX);
        label = "Score: ";
      }
      const dropWidth = 60, dropHeight = 30;
      const dropX = canvas.width - dropWidth - 20, dropY = 20;
      
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.moveTo(dropX, dropY + dropHeight/2);
      ctx.quadraticCurveTo(dropX + dropWidth, dropY, dropX + dropWidth, dropY + dropHeight/2);
      ctx.quadraticCurveTo(dropX + dropWidth, dropY+dropHeight, dropX, dropY+dropHeight/2);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = "white";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label + value + " m", dropX + dropWidth/2, dropY + dropHeight/2);
    }
    
    // === Javelin Physics ===
    function updateJavelinPhysics(dt) {
      let vx = javelin.vx, vy = javelin.vy;
      let v = Math.sqrt(vx*vx + vy*vy);
      if(v>0) {
        let dragForce = 0.5 * airDensity * v*v * dragCoefficient * javelinArea;
        let dragAccel = dragForce/javelinMass;
        let dragAx = -dragAccel*(vx/v);
        let dragAy = -dragAccel*(vy/v);
        javelin.vx += dragAx*dt;
        javelin.vy += dragAy*dt;
      }
      javelin.vy += gravity*dt;
      javelin.x += javelin.vx*dt;
      javelin.y += javelin.vy*dt;
    }
    
    // === Draw the Runner (Left arm bent, limbs attached) ===
    function drawRunner(x, scale, time, aiming, aimAngle) {
      // Basic vertical coordinates
      const headY = 1.8;
      const bodyTopY = 1.5;
      const hipY = 1.0;
      
      // Shoulder offsets
      const leftShoulderOffset = 0.3; // left side
      const rightShoulderOffset = 0.3; // right side
      const hipOffset = 0.1;
      
      // Head
      let headPos = worldToScreen(x, headY);
      ctx.fillStyle = "#ffe0bd";
      ctx.beginPath();
      ctx.arc(headPos.screenX, headPos.screenY, 0.2*scale, 0, Math.PI*2);
      ctx.fill();
      
      // Torso from (x, bodyTopY) to (x, hipY)
      let bodyTop = worldToScreen(x, bodyTopY);
      let bodyBottom = worldToScreen(x, hipY);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(bodyTop.screenX, bodyTop.screenY);
      ctx.lineTo(bodyBottom.screenX, bodyBottom.screenY);
      ctx.stroke();
      
      // Right arm: extended forward
      let rightShoulder = { x: x + rightShoulderOffset, y: bodyTopY };
      let rightHand = { x: rightShoulder.x + 0.4, y: bodyTopY - 0.1 };
      let rShoulderScr = worldToScreen(rightShoulder.x, rightShoulder.y);
      let rHandScr = worldToScreen(rightHand.x, rightHand.y);
      ctx.beginPath();
      ctx.moveTo(rShoulderScr.screenX, rShoulderScr.screenY);
      ctx.lineTo(rHandScr.screenX, rHandScr.screenY);
      ctx.stroke();
      
      // Left arm: throwing arm, bent elbow
      let leftShoulder = { x: x - leftShoulderOffset, y: bodyTopY };
      let defaultAngle = (20*Math.PI/180) + 0.2*Math.sin(time*8);
      let leftArmAngle = aiming ? aimAngle : defaultAngle;
      // Mirror angle for left side: desiredAngle = π - leftArmAngle
      let desiredAngle = Math.PI - leftArmAngle;
      const upperArmLength = 0.3;
      const lowerArmLength = 0.2;
      // We'll do a simple 45° offset for the elbow
      let upperArmAngle = desiredAngle + Math.PI/4;
      let elbow = {
        x: leftShoulder.x + upperArmLength*Math.cos(upperArmAngle),
        y: leftShoulder.y - upperArmLength*Math.sin(upperArmAngle)
      };
      let lowerArmAngle = upperArmAngle - Math.PI/2;
      let leftHandPos = {
        x: elbow.x + lowerArmLength*Math.cos(lowerArmAngle),
        y: elbow.y - lowerArmLength*Math.sin(lowerArmAngle)
      };
      let lShoulderScr = worldToScreen(leftShoulder.x, leftShoulder.y);
      let elbowScr = worldToScreen(elbow.x, elbow.y);
      let lHandScr = worldToScreen(leftHandPos.x, leftHandPos.y);
      ctx.beginPath();
      ctx.moveTo(lShoulderScr.screenX, lShoulderScr.screenY);
      ctx.lineTo(elbowScr.screenX, elbowScr.screenY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(elbowScr.screenX, elbowScr.screenY);
      ctx.lineTo(lHandScr.screenX, lHandScr.screenY);
      ctx.stroke();
      
      // Legs from hip
      let hip = { x: x + hipOffset, y: hipY };
      let hipScr = worldToScreen(hip.x, hip.y);
      let rightLegSwing = 0.6*Math.sin(time*8);
      let leftLegSwing = 0.6*Math.sin(time*8 + Math.PI);
      let rightLegEnd = { x: x+0.2*rightLegSwing, y: 0 };
      let leftLegEnd = { x: x+0.2*leftLegSwing, y: 0 };
      let rLegScr = worldToScreen(rightLegEnd.x, rightLegEnd.y);
      let lLegScr = worldToScreen(leftLegEnd.x, leftLegEnd.y);
      ctx.beginPath();
      ctx.moveTo(hipScr.screenX, hipScr.screenY);
      ctx.lineTo(rLegScr.screenX, rLegScr.screenY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(hipScr.screenX, hipScr.screenY);
      ctx.lineTo(lLegScr.screenX, lLegScr.screenY);
      ctx.stroke();
      
      return leftHandPos; // Return final left-hand position for javelin
    }
    
    // === Draw Javelin Attached to Runner's Hand ===
    function drawJavelinAtHand(handPos, scale, angle) {
      let posScr = worldToScreen(handPos.x, handPos.y);
      ctx.save();
      ctx.translate(posScr.screenX, posScr.screenY);
      ctx.rotate(-angle);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(javelinLength*scale,0);
      ctx.stroke();
      ctx.restore();
    }
    
    // === Main Game Loop ===
    let lastTime = 0;
    function gameLoop(timestamp) {
      if(!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime)/1000;
      lastTime = timestamp;
      
      runnerTime += dt;
      
      update(dt);
      draw();
      
      document.getElementById("result").innerText = resultText;
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
    
    // === Update Game State ===
    function update(dt) {
      if(gameState==="startTransition") {
        let elapsed = performance.now()-transitionStartTime;
        if(elapsed>=startTransitionDuration) {
          gameState="running";
        }
      }
      
      if(gameState==="running"||gameState==="aiming") {
        player.x += playerSpeed*dt;
        if(player.x>foulLineX) {
          gameState="foul";
          resultText="Foul! You crossed the line without throwing. Press R to restart.";
        }
        if(gameState==="aiming"&&spacePressed) {
          holdDuration=performance.now()-holdStartTime;
        }
      }
      
      if(gameState==="flightZoomOut"||gameState==="thrown"||gameState==="landingZoomIn") {
        updateJavelinPhysics(dt);
        if(javelin.y<=0) {
          // Use approach angle for finalAngle
          finalAngle = Math.atan2(-javelin.vy, javelin.vx);
          javelin.y=0;
          javelin.vx=0;
          javelin.vy=0;
          if(gameState!=="landingZoomIn") {
            landingZoomStartScale=initialScale;
            landingZoomStartCameraX=javelin.x-(canvas.width/(2*initialScale));
            landingCameraX=javelin.x-(canvas.width/(2*finalScale));
            gameState="landingZoomIn";
            landingTransitionStartTime=performance.now();
          }
        }
        if(gameState==="flightZoomOut") {
          let elapsed = performance.now()-flightTransitionStartTime;
          if(elapsed>=flightTransitionDuration) {
            gameState="thrown";
          }
        }
      }
      
      if(gameState==="landingZoomIn") {
        let elapsed = performance.now()-landingTransitionStartTime;
        if(elapsed>=landingTransitionDurationIn) {
          gameState="landed";
          let score=Math.floor(javelin.x-frozenPlayerX);
          resultText="Score: "+score+" m. Press R to restart.";
        }
      }
    }
    
    // === Draw Everything ===
    function draw() {
      const { scale, cameraX } = getCameraAndScale();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      
      // Sky
      let skyGradient=ctx.createLinearGradient(0,0,0,canvas.height);
      skyGradient.addColorStop(0,"#87CEEB");
      skyGradient.addColorStop(1,"#B0E0E6");
      ctx.fillStyle=skyGradient;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      
      // Landscape
      drawLandscape();
      
      // Ground
      ctx.fillStyle="#228B22";
      ctx.fillRect(0,canvas.height-bottomMargin,canvas.width,bottomMargin);
      
      drawMeterMarkings(cameraX,scale);
      
      let foulScr=worldToScreen(foulLineX,0);
      ctx.strokeStyle="red";
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(foulScr.screenX,0);
      ctx.lineTo(foulScr.screenX,canvas.height);
      ctx.stroke();
      
      // Draw runner if in running or aiming
      if(gameState==="running"||gameState==="aiming") {
        let angleFactor=Math.min(holdDuration,maxHoldTime)/maxHoldTime;
        let aimAngle=minAngle+(maxAngle-minAngle)*angleFactor;
        if(gameState!=="aiming") {
          aimAngle=(20*Math.PI/180)+0.2*Math.sin(runnerTime*8); 
        }
        let leftHandPos=drawRunner(player.x,scale,runnerTime,gameState==="aiming",aimAngle);
        drawJavelinAtHand(leftHandPos,scale,aimAngle);
      }
      
      // Javelin flight or landed
      if(gameState==="flightZoomOut"||gameState==="thrown"||gameState==="landingZoomIn"||gameState==="landed") {
        let pos=worldToScreen(javelin.x,javelin.y);
        let angle;
        if(gameState==="landed") {
          angle=finalAngle;
          // offset so tip is embedded
          pos={
            screenX:pos.screenX+10*Math.sin(angle),
            screenY:pos.screenY+10*Math.cos(angle)
          };
        } else {
          angle=Math.atan2(-javelin.vy,javelin.vx);
        }
        ctx.save();
        ctx.translate(pos.screenX,pos.screenY);
        ctx.rotate(angle);
        ctx.strokeStyle="black";
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(javelinLength*scale,0);
        ctx.stroke();
        ctx.restore();
      }
      
      drawDistanceIndicator();
      
      if(gameState==="ready") {
        ctx.strokeStyle="black";
        ctx.lineWidth=2;
        ctx.strokeRect(0,0,canvas.width,canvas.height);
      }
    }
    
    function resetGame() {
      gameState="ready";
      resultText="Press the button or Space to start running.";
      player={ x:0,y:0 };
      javelin={ x:0,y:0,vx:0,vy:0 };
      frozenPlayerX=0;
      spacePressed=false;
      holdDuration=0;
      holdStartTime=0;
      transitionStartTime=null;
      flightTransitionStartTime=null;
      landingTransitionStartTime=null;
      aimTransitionStartTime=null;
    }
    
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>

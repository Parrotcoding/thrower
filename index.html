<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Javelin Throwing Game – Realistic Physics</title>
  <style>
    body {
      margin: 0;
      background: #87CEEB;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    canvas {
      display: block;
      margin: 20px auto;
      border: 2px solid #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      background: #87CEEB;
    }
    #result {
      font-size: 20px;
      margin-top: 10px;
      color: #333;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div id="result"></div>
  
  <script>
    // === Canvas & Context ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // === Field & Scaling Constants ===
    const fieldWidth = 120;            // Field width in meters (realistic field)
    const bottomMargin = 40;           // Space at bottom for ground & meter markings
    const initialScale = canvas.width / fieldWidth; // Full-field view scale (zoomed out)
    const finalScale = 50;             // Running view: 1 m = 50 pixels (zoomed in)
    const aimScale = (initialScale + finalScale) / 2; // Intermediate scale for aiming
    
    // === Transition Durations (in ms) ===
    const startTransitionDuration = 1000;       // Zoom in from full field to running view at start
    const flightTransitionDuration = 1000;        // Zoom out from running view to full-field view after throw
    const landingTransitionDurationIn = 1000;     // Zoom in on landing spot after flight
    
    // === Global State & Timing Variables ===
    // Game states:
    // "ready": full field view waiting to start.
    // "startTransition": zooming in to running view.
    // "running": player is moving (camera centered on player, zoomed in).
    // "aiming": player holding Space to aim (using aimScale).
    // "flightZoomOut": immediately after throw, zooming out to full-field view.
    // "thrown": javelin in flight in full-field view (camera scrolls with the javelin).
    // "landingZoomIn": after landing, zooming in on the landing spot.
    // "landed": final view (zoomed in on landing spot) with result.
    // "foul": foul (crossed throwing line without throwing).
    let gameState = "ready";
    let resultText = "Press Space to start running (full field view).";
    
    let transitionStartTime = null;         // For startTransition
    let flightTransitionStartTime = null;     // For flightZoomOut
    let landingTransitionStartTime = null;    // For landingZoomIn
    
    // For landing zoom interpolation.
    let landingZoomStartCameraX = null;
    let landingZoomStartScale = null;
    let landingCameraX = null;
    
    // === World Physics (SI units) ===
    const gravity = -9.81;           // m/s² (downward)
    const playerSpeed = 7;           // m/s
    const throwSpeed = 30;           // m/s
    const minAngle = 20 * Math.PI/180; // radians
    const maxAngle = 60 * Math.PI/180; // radians
    const maxHoldTime = 2000;        // ms maximum for aiming
    
    // Additional parameters for realistic physics (drag)
    const airDensity = 1.225;        // kg/m³ (at sea level)
    const dragCoefficient = 0.5;     // Typical for a streamlined object
    const javelinArea = 0.007;       // Estimated cross-sectional area in m²
    const javelinMass = 0.8;         // Mass of the javelin in kg
    
    // === World Objects ===
    let player = { x: 0, y: 0 };      // Starting at 0 m (ground is y = 0)
    const playerRadius = 0.3;        // meters (drawn as circle)
    const foulLineX = 30;            // Foul (throwing) line in meters
    
    let javelin = { x: 0, y: 0, vx: 0, vy: 0 };
    const javelinLength = 1.2;       // meters
    
    let frozenPlayerX = 0;           // Freeze player x at throw time
    
    // === Input Control Variables ===
    let spacePressed = false;
    let holdStartTime = 0;
    let holdDuration = 0;
    
    // === Camera & View Function ===
    function getCameraAndScale() {
      let scale, cameraX;
      if (gameState === "ready") {
        scale = initialScale;
        cameraX = 0;
      } else if (gameState === "startTransition") {
        let elapsed = performance.now() - transitionStartTime;
        let fraction = Math.min(elapsed / startTransitionDuration, 1);
        scale = initialScale + fraction * (finalScale - initialScale);
        let runningCameraX = player.x - (canvas.width / (2 * finalScale));
        cameraX = fraction * runningCameraX;
      } else if (gameState === "running") {
        scale = finalScale;
        cameraX = player.x - (canvas.width / (2 * finalScale));
      } else if (gameState === "aiming") {
        scale = aimScale;
        cameraX = player.x - (canvas.width / (2 * aimScale));
      } else if (gameState === "flightZoomOut") {
        let elapsed = performance.now() - flightTransitionStartTime;
        let fraction = Math.min(elapsed / flightTransitionDuration, 1);
        scale = finalScale + fraction * (initialScale - finalScale);
        let runningCameraX = frozenPlayerX - (canvas.width / (2 * finalScale));
        let fullFieldCameraX = javelin.x - (canvas.width / (2 * initialScale));
        cameraX = runningCameraX + fraction * (fullFieldCameraX - runningCameraX);
      } else if (gameState === "thrown") {
        scale = initialScale;
        cameraX = javelin.x - (canvas.width / (2 * initialScale));
      } else if (gameState === "landingZoomIn") {
        let elapsed = performance.now() - landingTransitionStartTime;
        let fraction = Math.min(elapsed / landingTransitionDurationIn, 1);
        scale = landingZoomStartScale + fraction * (finalScale - landingZoomStartScale);
        cameraX = landingZoomStartCameraX + fraction * (landingCameraX - landingZoomStartCameraX);
      } else if (gameState === "landed") {
        scale = finalScale;
        cameraX = landingCameraX;
      } else if (gameState === "foul") {
        scale = finalScale;
        cameraX = frozenPlayerX - (canvas.width / (2 * finalScale));
      }
      return { scale, cameraX };
    }
    
    function worldToScreen(x, y) {
      const { scale, cameraX } = getCameraAndScale();
      let screenX = (x - cameraX) * scale;
      let screenY = canvas.height - bottomMargin - y * scale;
      return { screenX, screenY };
    }
    
    // === Draw Meter Markings (every 5 m) ===
    function drawMeterMarkings(cameraX, scale) {
      ctx.fillStyle = "black";
      ctx.strokeStyle = "black";
      ctx.font = "12px Arial";
      let startMark = Math.ceil(cameraX / 5) * 5;
      let endMark = Math.floor((cameraX + canvas.width / scale) / 5) * 5;
      for (let m = startMark; m <= endMark; m += 5) {
        let xPos = (m - cameraX) * scale;
        ctx.beginPath();
        ctx.moveTo(xPos, canvas.height - bottomMargin);
        ctx.lineTo(xPos, canvas.height - bottomMargin + 10);
        ctx.stroke();
        ctx.fillText(m + " m", xPos - 15, canvas.height - bottomMargin + 22);
      }
    }
    
    // === Draw Distance Indicator ===
    function drawDistanceIndicator() {
      // Compute distance from foul line (player's x before throw; javelin's x after)
      let distance;
      if (gameState === "thrown" || gameState === "flightZoomOut" ||
          gameState === "landingZoomIn" || gameState === "landed") {
        distance = Math.round(javelin.x - foulLineX);
      } else {
        distance = Math.round(foulLineX - player.x);
      }
      
      const dropWidth = 60;
      const dropHeight = 30;
      const dropX = canvas.width - dropWidth - 20;
      const dropY = 20;
      
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.moveTo(dropX, dropY + dropHeight / 2);
      ctx.quadraticCurveTo(dropX + dropWidth, dropY, dropX + dropWidth, dropY + dropHeight / 2);
      ctx.quadraticCurveTo(dropX + dropWidth, dropY + dropHeight, dropX, dropY + dropHeight / 2);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = "white";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(distance + " m", dropX + dropWidth / 2, dropY + dropHeight / 2);
    }
    
    // === Main Game Loop ===
    let lastTime = 0;
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      
      update(dt);
      draw();
      
      document.getElementById("result").innerText = resultText;
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
    
    // === Update Game State ===
    function update(dt) {
      // Transition: full-field to running view.
      if (gameState === "startTransition") {
        let elapsed = performance.now() - transitionStartTime;
        if (elapsed >= startTransitionDuration) {
          gameState = "running";
        }
      }
      
      if (gameState === "running" || gameState === "aiming") {
        player.x += playerSpeed * dt;
        if (player.x > foulLineX) {
          gameState = "foul";
          resultText = "Foul! You crossed the line without throwing. Press R to restart.";
        }
        if (gameState === "aiming" && spacePressed) {
          holdDuration = performance.now() - holdStartTime;
        }
      }
      
      // For flight phases, update javelin physics with gravity and aerodynamic drag.
      if (gameState === "flightZoomOut" || gameState === "thrown" || gameState === "landingZoomIn") {
        // Compute drag force
        let vx = javelin.vx, vy = javelin.vy;
        let v = Math.sqrt(vx * vx + vy * vy);
        let dragAx = 0, dragAy = 0;
        if (v > 0) {
          let dragForce = 0.5 * airDensity * v * v * dragCoefficient * javelinArea;
          let dragAccel = dragForce / javelinMass;
          dragAx = -dragAccel * (vx / v);
          dragAy = -dragAccel * (vy / v);
        }
        // Apply gravity and drag
        javelin.vx += dragAx * dt;
        javelin.vy += (gravity + dragAy) * dt;
        javelin.x += javelin.vx * dt;
        javelin.y += javelin.vy * dt;
        
        // Transition check: if javelin touches ground.
        if (javelin.y <= 0) {
          javelin.y = 0;
          javelin.vx = 0;
          javelin.vy = 0;
          landingZoomStartScale = initialScale;
          landingZoomStartCameraX = javelin.x - (canvas.width / (2 * initialScale));
          landingCameraX = javelin.x - (canvas.width / (2 * finalScale));
          gameState = "landingZoomIn";
          landingTransitionStartTime = performance.now();
        }
        
        // For flight zoom out transition timing.
        if (gameState === "flightZoomOut") {
          let elapsed = performance.now() - flightTransitionStartTime;
          if (elapsed >= flightTransitionDuration) {
            gameState = "thrown";
          }
        }
      }
      
      if (gameState === "landingZoomIn") {
        let elapsed = performance.now() - landingTransitionStartTime;
        if (elapsed >= landingTransitionDurationIn) {
          gameState = "landed";
          let distance = javelin.x - foulLineX;
          resultText = "Distance: " + distance.toFixed(2) + " m. Press R to restart.";
        }
      }
    }
    
    // === Draw Everything ===
    function draw() {
      const { scale, cameraX } = getCameraAndScale();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, "#87CEEB");
      skyGradient.addColorStop(1, "#B0E0E6");
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = "#228B22";
      ctx.fillRect(0, canvas.height - bottomMargin, canvas.width, bottomMargin);
      
      drawMeterMarkings(cameraX, scale);
      
      let foulScreen = worldToScreen(foulLineX, 0);
      ctx.strokeStyle = "red";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(foulScreen.screenX, 0);
      ctx.lineTo(foulScreen.screenX, canvas.height);
      ctx.stroke();
      
      // --- Preview Dots in Aiming Mode ---
      if (gameState === "aiming" && spacePressed) {
        let angleFactor = Math.min(holdDuration, maxHoldTime) / maxHoldTime;
        let angle = minAngle + (maxAngle - minAngle) * angleFactor;
        let initVx = playerSpeed + throwSpeed * Math.cos(angle);
        let initVy = throwSpeed * Math.sin(angle);
        let startX = player.x;
        let startY = player.y + 0.5; // javelin starting height (m)
        let numDots = 10;
        let dotInterval = 0.2;
        ctx.fillStyle = "black";
        for (let i = 1; i <= numDots; i++) {
          let t = i * dotInterval;
          let dotX = startX + initVx * t;
          let dotY = startY + initVy * t + 0.5 * gravity * t * t;
          if (dotY < 0) break;
          let pos = worldToScreen(dotX, dotY);
          let dotRadius = 0.1 * scale;
          ctx.beginPath();
          ctx.arc(pos.screenX, pos.screenY, dotRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // --- Draw the Player ---
      if (gameState === "running" || gameState === "aiming") {
        let playerScreen = worldToScreen(player.x, player.y);
        ctx.fillStyle = "#0000FF";
        ctx.beginPath();
        ctx.arc(playerScreen.screenX, playerScreen.screenY, playerRadius * scale, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // --- Draw the Javelin ---
      if (gameState === "aiming") {
        let angleFactor = Math.min(holdDuration, maxHoldTime) / maxHoldTime;
        let angle = minAngle + (maxAngle - minAngle) * angleFactor;
        let pos = worldToScreen(player.x, player.y + 0.5);
        ctx.save();
        ctx.translate(pos.screenX, pos.screenY);
        ctx.rotate(-angle);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(javelinLength * scale, 0);
        ctx.stroke();
        ctx.restore();
      } else if (gameState === "flightZoomOut" || gameState === "thrown" ||
                 gameState === "landingZoomIn" || gameState === "landed") {
        let pos = worldToScreen(javelin.x, javelin.y);
        // Compute the correct screen angle (inverting the y–component).
        let angle = Math.atan2(-javelin.vy, javelin.vx);
        ctx.save();
        ctx.translate(pos.screenX, pos.screenY);
        ctx.rotate(angle);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(javelinLength * scale, 0);
        ctx.stroke();
        ctx.restore();
      }
      
      // --- Draw the Distance Indicator ---
      drawDistanceIndicator();
      
      if (gameState === "ready") {
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
      }
    }
    
    // === Input Event Listeners ===
    document.addEventListener('keydown', function(e) {
      if (e.code === "Space") {
        if (gameState === "ready") {
          gameState = "startTransition";
          transitionStartTime = performance.now();
          resultText = "";
        } else if (gameState === "running") {
          gameState = "aiming";
          spacePressed = true;
          holdStartTime = performance.now();
          holdDuration = 0;
        }
      }
      if (e.code === "KeyR") {
        resetGame();
      }
    });
    
    document.addEventListener('keyup', function(e) {
      if (e.code === "Space") {
        if (gameState === "aiming" && spacePressed) {
          spacePressed = false;
          let angleFactor = Math.min(holdDuration, maxHoldTime) / maxHoldTime;
          let angle = minAngle + (maxAngle - minAngle) * angleFactor;
          javelin.x = player.x;
          javelin.y = player.y + 0.5;
          javelin.vx = playerSpeed + throwSpeed * Math.cos(angle);
          javelin.vy = throwSpeed * Math.sin(angle);
          frozenPlayerX = player.x;
          gameState = "flightZoomOut";
          flightTransitionStartTime = performance.now();
        }
      }
    });
    
    function resetGame() {
      gameState = "ready";
      resultText = "Press Space to start running (full field view).";
      player.x = 0;
      player.y = 0;
      javelin = { x: 0, y: 0, vx: 0, vy: 0 };
      frozenPlayerX = 0;
      spacePressed = false;
      holdDuration = 0;
      holdStartTime = 0;
      transitionStartTime = null;
      flightTransitionStartTime = null;
      landingTransitionStartTime = null;
    }
  </script>
</body>
</html>
